buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.ajoberstar:gradle-git:1.6.0'
    }
}

plugins {
    id 'java-library'
    id 'maven-publish'
    id 'signing'
}

defaultTasks 'info'

ext.versionNumber = "5.0"
ext.buildNumber = "SNAPSHOT"
try {
    ext.repoId = org.ajoberstar.grgit.Grgit.open(project.file('.')).head().abbreviatedId;
} catch (Exception e) {
    ext.repoId = "unknown"
}

repositories {
    //    mavenCentral()
}

dependencies {
    //    testCompile 'junit:junit:4.11'
}

compileJava {
    options.compilerArgs = [
            '-source', '1.8',
            '-target', '1.8',
            '-profile', 'compact3',
            '-Xlint:unchecked'
    ]
}

compileTestJava {
    options.compilerArgs += '-proc:none' // 'org.pcj.internal.StorageAnnotationProcessor'
}

task info {
    println "PCJ -- Parallel Computing in Java build script"
}

task javadoc(overwrite: true, type: Javadoc) {
    failOnError = false
    source = sourceSets.main.allJava
    exclude "org/pcj/internal/**"
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    from 'LICENSE'
    from javadoc.destinationDir
    classifier = 'javadoc'
}

task sourcesJar(type: Jar) {
    from 'LICENSE'
    from sourceSets.main.allJava
    from sourceSets.main.resources
    classifier = 'sources'
}

task releaseBuild {
    outputs.upToDateWhen { false }
//    releaseBuild.dependsOn(clean, jar, javadocJar, sourcesJar, publish)
    releaseBuild.dependsOn(jar, javadocJar, sourcesJar, publish)
}

gradle.taskGraph.whenReady { taskGraph ->
    def properties = new Properties()

    def versionFile = file('build.version')
    if (versionFile.canRead()) {
        properties.load(new FileInputStream(versionFile))
    }

    if (properties['build.number'] == null) {
        properties['build.number'] = '0'
    }

    buildNumber = properties['build.number']
    if (taskGraph.hasTask(releaseBuild)) {
        publish.doLast {
            properties['build.number'] = (buildNumber.toInteger() + 1).toString()
            properties.store(versionFile.newWriter(), null)
        }
    } else {
        if (taskGraph.hasTask(publish)) {
            buildNumber = "$buildNumber-SNAPSHOT"
        } else {
            buildNumber = "$buildNumber-SNAPSHOT-$repoId"
        }
    }
    version = "$versionNumber.$buildNumber"
    jar.doFirst {
        classifier = ''
        manifest {
            attributes('Implementation-Version': "$versionNumber.$buildNumber-$repoId")
        }
    }

//    def snapshotsRepoUrl = "$buildDir/repos/snapshots"
//    def releasesRepoUrl = "$buildDir/repos/releases"
    def snapshotsRepoUrl = "https://oss.sonatype.org/content/repositories/snapshots"
    def releasesRepoUrl = "https://oss.sonatype.org/service/local/staging/deploy/maven2"
    publishing.repositories.maven.url = buildNumber.contains('SNAPSHOT') ? snapshotsRepoUrl : releasesRepoUrl
    if (publishing.repositories.maven.url.scheme == "https") {
        publishing.repositories.maven.credentials {
            username sonatypeUsername
            password sonatypePassword
        }
    }
}

jar {
    from 'LICENSE'
    manifest {
        attributes('Implementation-Version': "$repoId",
                'Implementation-Vendor': System.getProperty('user.name'),
                'Implementation-Title': date,
                'Sealed': true,
                // 'Profile': 'compact3',
        )
        attributes(['Sealed': false], 'org/pcj/')
    }
}

def getDate() {
    def date = new Date()
    def formattedDate = date.format('yyyy-MM-dd HH:mm:ss.SSS z')
    return formattedDate
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            groupId = 'pl.edu.icm.pcj'
            artifactId = 'pcj'
            artifact sourcesJar
            artifact javadocJar
            pom {
                from components.java
                packaging 'jar'
                name = 'PCJ'
                description = 'PCJ is Java library for parallel computing in Java. It is based on the PGAS (Partitioned Global Address Space) paradigm. It allows for easy implementation in Java of any parallel algorithm. PCJ application can be run on laptop, workstation, cluster and HPC system including large supercomputers.'
                url = 'http://pcj.icm.edu.pl'
                licenses {
                    license {
                        name = 'The 3-Clause BSD License'
                        url = 'https://opensource.org/licenses/BSD-3-Clause'
                    }
                }
                developers {
                    developer {
                        id = 'faramir'
                        name = 'Marek Nowicki'
                        email = 'faramir@mat.umk.pl'
                    }
                }
                scm {
                    url = 'https://github.com/hpdcj/PCJ'
                    connection = 'scm:git:git://github.com/hpdcj/PCJ.git'
                    developerConnection = 'scm:git:git@github.com:hpdcj/PCJ.git'
                }
            }
        }
    }
    repositories {
        maven {
            url = "$buildDir/repos/unknown"
        }
    }
}

signing {
    sign publishing.publications.mavenJava
}


// Code needed for running Main classes from Task Packages in NetBeans
def createJavaExec = { String taskName ->
    project.task(taskName, dependsOn: project.testClasses, type: JavaExec) {
        def definedMainClass = project.hasProperty('mainClass') ? project.mainClass : ''
        if (definedMainClass == null) definedMainClass = ''
        definedMainClass = definedMainClass.toString()

        main = definedMainClass
        classpath = project.sourceSets.test.runtimeClasspath
        standardInput = System.in
        //jvmArgs = ["-Xmx3g","-Xms3g"]
        maxHeapSize = "2g"

    }
}

createJavaExec('run')
